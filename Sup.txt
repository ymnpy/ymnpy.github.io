import os
import sys
import numpy as np
import pandas as pd
import subprocess
import shutil
import time
import psutil
import ast
import gc
from typing import Set, List, Dict, Optional, Tuple

from pyNastran.bdf.bdf import read_bdf
from pyNastran.op2.op2 import read_op2
from pyNastran.bdf.mesh_utils.mass_properties import mass_properties

from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                             QHBoxLayout, QLabel, QLineEdit, QPushButton,
                             QTextEdit, QProgressBar, QGroupBox, QSplitter,
                             QFileDialog, QMessageBox, QSpinBox, QDoubleSpinBox,
                             QComboBox, QRadioButton, QButtonGroup)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QFont

import matplotlib
matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt  # <-- ADDED THIS LINE
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

# Optional for Gaussian optimization
try:
    from skopt import gp_minimize
    from skopt.space import Real
    SKOPT_AVAILABLE = True
except ImportError:
    SKOPT_AVAILABLE = False

class PCOMPOptimizerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PCOMP Thickness Optimizer v2.0")
        self.resize(1400, 900)
        self.apply_modern_style()
        
        # State variables
        self.iteration_data = []
        self.initial_mass = None
        self.node_to_shells_cache = None
        self.target_pcomp_ids = None  # For Excel-based property selection
        self.angle_tolerance=30
        
        # Build UI
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        splitter = QSplitter(Qt.Horizontal)
        QHBoxLayout(main_widget).addWidget(splitter)
        
        splitter.addWidget(self.create_left_panel())
        splitter.addWidget(self.create_right_panel())
        splitter.setSizes([450, 950])
        
    
    def apply_modern_style(self):
        """Half-Life HEV Suit inspired compact theme"""
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #0a0a0a;
                color: #d4d4d4;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 9pt;
            }
            QGroupBox {
                border: 1px solid #ff6600;
                border-radius: 3px;
                margin-top: 8px;
                padding-top: 8px;
                font-weight: bold;
                color: #ff8800;
                font-size: 8pt;
            }
            QGroupBox::title { 
                subcontrol-origin: margin; 
                left: 8px; 
                padding: 0 3px;
                background-color: #0a0a0a;
            }
            QLineEdit, QSpinBox, QDoubleSpinBox, QComboBox {
                background-color: #1a1a1a;
                border: 1px solid #444444;
                border-radius: 2px;
                padding: 3px 5px;
                color: #00ff00;
                selection-background-color: #ff6600;
                font-size: 9pt;
            }
            QLineEdit:focus, QSpinBox:focus, QDoubleSpinBox:focus, QComboBox:focus {
                border: 1px solid #ff6600;
                background-color: #222222;
            }
            QLineEdit:disabled, QSpinBox:disabled, QDoubleSpinBox:disabled {
                background-color: #0f0f0f;
                color: #555555;
                border: 1px solid #2a2a2a;
            }
            QComboBox::drop-down { 
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow { 
                image: none;
                border-left: 3px solid transparent;
                border-right: 3px solid transparent;
                border-top: 5px solid #ff6600;
                margin-right: 5px;
            }
            QPushButton {
                background-color: #2a2a2a;
                color: #ff8800;
                border: 1px solid #ff6600;
                border-radius: 2px;
                padding: 5px 12px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover { 
                background-color: #3a3a3a;
                border: 1px solid #ff8800;
                color: #ffaa00;
            }
            QPushButton:pressed { 
                background-color: #ff6600;
                color: #000000;
            }
            QPushButton:disabled { 
                background-color: #1a1a1a;
                color: #444444;
                border: 1px solid #2a2a2a;
            }
            QRadioButton { 
                color: #d4d4d4;
                spacing: 5px;
                font-size: 9pt;
            }
            QRadioButton::indicator { 
                width: 12px;
                height: 12px;
            }
            QRadioButton::indicator::unchecked { 
                border: 1px solid #555555;
                border-radius: 6px;
                background: #1a1a1a;
            }
            QRadioButton::indicator::checked { 
                border: 1px solid #ff6600;
                border-radius: 6px;
                background: qradialgradient(cx:0.5, cy:0.5, radius:0.5,
                    fx:0.5, fy:0.5, stop:0 #ff6600, stop:0.5 #ff8800, stop:1 #ff6600);
            }
            QRadioButton::indicator::checked:hover {
                background: qradialgradient(cx:0.5, cy:0.5, radius:0.5,
                    fx:0.5, fy:0.5, stop:0 #ff8800, stop:0.5 #ffaa00, stop:1 #ff8800);
            }
            QTextEdit {
                background-color: #0f0f0f;
                border: 1px solid #444444;
                border-radius: 2px;
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 8pt;
                color: #00ff00;
                selection-background-color: #ff6600;
            }
            QProgressBar {
                border: 1px solid #444444;
                border-radius: 2px;
                text-align: center;
                background-color: #1a1a1a;
                height: 18px;
                color: #d4d4d4;
                font-weight: bold;
                font-size: 8pt;
            }
            QProgressBar::chunk {
                background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #ff4400, stop:0.5 #ff6600, stop:1 #ff8800);
                border-radius: 1px;
            }
            QLabel { 
                color: #aaaaaa;
                font-size: 9pt;
            }
            QScrollBar:vertical {
                border: none;
                background: #2a2a2a;
                width: 10px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #2a2a2a;
                min-height: 20px;
                border-radius: 2px;
            }
            # QScrollBar::handle:vertical:hover {
            #     background: #ff8800;
            # }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar:horizontal {
                border: none;
                background: #1a1a1a;
                height: 10px;
                margin: 0;
            }
            QScrollBar::handle:horizontal {
                background: #ff6600;
                min-width: 20px;
                border-radius: 2px;
            }
            QScrollBar::handle:horizontal:hover {
                background: #ff8800;
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)
        
    def apply_modern_style2(self):
        """Modern dark theme - unchanged"""
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #1e1e1e;
                color: #e0e0e0;
                font-family: 'Segoe UI', Arial;
                font-size: 10pt;
            }
            QGroupBox {
                border: 2px solid #3d3d3d;
                border-radius: 8px;
                margin-top: 12px;
                padding-top: 12px;
                font-weight: bold;
                color: #4fc3f7;
            }
            QGroupBox::title { subcontrol-origin: margin; left: 10px; padding: 0 5px; }
            QLineEdit, QSpinBox, QDoubleSpinBox, QComboBox {
                background-color: #2d2d2d;
                border: 2px solid #3d3d3d;
                border-radius: 6px;
                padding: 6px;
                color: #e0e0e0;
            }
            QLineEdit:focus, QSpinBox:focus, QDoubleSpinBox:focus, QComboBox:focus {
                border: 2px solid #4fc3f7;
            }
            QComboBox::drop-down { border: none; }
            QComboBox::down-arrow { 
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 6px solid #e0e0e0;
                margin-right: 8px;
            }
            QPushButton {
                background-color: #0d47a1;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #1565c0; }
            QPushButton:pressed { background-color: #0a3d8f; }
            QPushButton:disabled { background-color: #3d3d3d; color: #808080; }
            QRadioButton { color: #e0e0e0; }
            QRadioButton::indicator { width: 16px; height: 16px; }
            QRadioButton::indicator::unchecked { 
                border: 2px solid #3d3d3d;
                border-radius: 8px;
                background: #2d2d2d;
            }
            QRadioButton::indicator::checked { 
                border: 2px solid #4fc3f7;
                border-radius: 8px;
                background: #4fc3f7;
            }
            QTextEdit {
                background-color: #252525;
                border: 2px solid #3d3d3d;
                border-radius: 6px;
                font-family: 'Consolas', monospace;
                font-size: 9pt;
            }
            QProgressBar {
                border: 2px solid #3d3d3d;
                border-radius: 6px;
                text-align: center;
                background-color: #2d2d2d;
                height: 24px;
            }
            QProgressBar::chunk {
                background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4fc3f7, stop:1 #0d47a1);
                border-radius: 4px;
            }
            QLabel { color: #b0b0b0; }
        """)
        
    def create_left_panel(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setSpacing(12)
        
        files = QGroupBox("FILES")
        fl = QVBoxLayout()
        fl.setSpacing(3)
        
        for name, attr in [("BDF", "bdf_path"), ("OP2", "op2_path"), 
                          ("Excel", "excel_path"), ("Nastran", "nastran_path")]:
            hl = QHBoxLayout()
            
            # Create label with fixed width
            label = QLabel(f"{name}:")
            label.setMinimumWidth(60)  # ← Fixed width for alignment
            label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)  # Right-align text
            hl.addWidget(label)
            
            le = QLineEdit()
            setattr(self, attr, le)
            if name == "Nastran":
                le.setText(r"C:\MSC.Software\MSC_Nastran\20180\bin\nastran.exe")
            hl.addWidget(le, 1)
            
            btn = QPushButton("λ")  # Compact browse button
            btn.setMinimumWidth(30)
            btn.setToolTip(f"Browse for {name} file")
            btn.clicked.connect(getattr(self, f"browse_{attr.split('_')[0]}"))
            hl.addWidget(btn)
            
            fl.addLayout(hl)
        
        files.setLayout(fl)
        layout.addWidget(files)
        
        # PROPERTY SELECTION GROUP
        prop_group = QGroupBox("PROPERTY SELECTION")
        pg_layout = QVBoxLayout()
        
        # Radio buttons for property selection method
        self.prop_method_group = QButtonGroup()
        
        # Option 1: Neighbor Approach (just the radio button)
        self.prop_neighbor_radio = QRadioButton("Neighbor Approach (auto-detect)")
        self.prop_method_group.addButton(self.prop_neighbor_radio, 0)
        self.prop_neighbor_radio.setChecked(True)
        pg_layout.addWidget(self.prop_neighbor_radio)
        
        # Option 2: Manual Property IDs (radio button + input on same line)
        manual_layout = QHBoxLayout()
        self.prop_manual_radio = QRadioButton("Manual Property IDs:")
        self.prop_method_group.addButton(self.prop_manual_radio, 1)
        manual_layout.addWidget(self.prop_manual_radio)
        
        # Property ID input right next to the radio button
        self.prop_ids_input = QLineEdit()
        self.prop_ids_input.setPlaceholderText("e.g., all / 101,102 / 101:201")
        self.prop_ids_input.setEnabled(False)
        manual_layout.addWidget(self.prop_ids_input, 1)  # Stretch factor 1
        
        pg_layout.addLayout(manual_layout)
        
        # Connect radio toggle to enable/disable input
        self.prop_manual_radio.toggled.connect(
            lambda checked: self.prop_ids_input.setEnabled(checked)
        )
        
        prop_group.setLayout(pg_layout)
        layout.addWidget(prop_group)
        
        # ALGORITHM SELECTION GROUP
        algo_group = QGroupBox("ALGORITHM")
        ag_layout = QVBoxLayout()
        
        self.algo_method_group = QButtonGroup()
        
        self.algo_lazy_radio = QRadioButton("Lazy (iterative thickness addition)")
        self.algo_gauss_radio = QRadioButton("Gaussian Process (optimization)")
        
        self.algo_method_group.addButton(self.algo_lazy_radio, 0)
        self.algo_method_group.addButton(self.algo_gauss_radio, 1)
        self.algo_lazy_radio.setChecked(True)
        
        ag_layout.addWidget(self.algo_lazy_radio)
        ag_layout.addWidget(self.algo_gauss_radio)
        
        if not SKOPT_AVAILABLE:
            self.algo_gauss_radio.setEnabled(False)
            self.algo_gauss_radio.setToolTip("Install scikit-optimize: pip install scikit-optimize")
        
        algo_group.setLayout(ag_layout)
        layout.addWidget(algo_group)
        
        # SETTINGS GROUP
        settings = QGroupBox("SETTINGS")
        sl = QVBoxLayout()
        
        # Thickness addition (for lazy algorithm)
        hl = QHBoxLayout()
        self.thickness_label = QLabel("Thickness (mm):")
        hl.addWidget(self.thickness_label)
        self.thickness_addition = QDoubleSpinBox()
        self.thickness_addition.setRange(0.1, 50.0)
        self.thickness_addition.setValue(0.736)
        self.thickness_addition.setDecimals(3)
        hl.addWidget(self.thickness_addition)
        sl.addLayout(hl)
        
        # Connect algorithm selection to change label and range
        self.algo_lazy_radio.toggled.connect(self.update_thickness_mode)
        self.algo_gauss_radio.toggled.connect(self.update_thickness_mode)

        # Target RF
        hl = QHBoxLayout()
        hl.addWidget(QLabel("Target RF:"))
        self.target_rf = QDoubleSpinBox()
        self.target_rf.setRange(1.0, 5.0)
        self.target_rf.setValue(1.0)
        self.target_rf.setDecimals(2)
        hl.addWidget(self.target_rf)
        sl.addLayout(hl)
        
        # Max iterations
        hl = QHBoxLayout()
        hl.addWidget(QLabel("Max Iterations:"))
        self.max_iterations = QSpinBox()
        self.max_iterations.setRange(1, 100)
        self.max_iterations.setValue(20)
        hl.addWidget(self.max_iterations)
        sl.addLayout(hl)
        
        # Angle tolerance (for neighbor approach)
        # hl = QHBoxLayout()
        # hl.addWidget(QLabel("Angle Tol (°):"))
        # self.angle_tolerance = QDoubleSpinBox()
        # self.angle_tolerance.setRange(0, 90)
        # self.angle_tolerance.setValue(30.0)
        # self.angle_tolerance.setDecimals(1)
        # hl.addWidget(self.angle_tolerance)
        # sl.addLayout(hl)
        
        settings.setLayout(sl)
        layout.addWidget(settings)
        
        # STATUS GROUP (same as before)
        status = QGroupBox("STATUS")
        stl = QVBoxLayout()
        
        self.progress = QProgressBar()
        stl.addWidget(self.progress)
        
        for lbl, attr, clr in [("Status", "status_label", "#ff8800"),
                               ("Iteration", "iteration_label", "#00ff00"),
                               ("Critical", "critical_label", "#ff4400")]:
            hl = QHBoxLayout()
            hl.addWidget(QLabel(f"{lbl}:"))
            label = QLabel("Ready" if lbl == "Status" else ("0/0" if lbl == "Iteration" else "---"))
            label.setStyleSheet(f"color: {clr}; font-weight: bold;")
            setattr(self, attr, label)
            hl.addWidget(label, 1)
            stl.addLayout(hl)
        
        status.setLayout(stl)
        layout.addWidget(status)
        
        # START BUTTON
        self.start_btn = QPushButton("▶ Start Optimization")
        self.start_btn.setMinimumHeight(40)
        self.start_btn.clicked.connect(self.start_optimization)
        layout.addWidget(self.start_btn)
        
        # LOG
        log = QGroupBox("LOG")
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        QVBoxLayout(log).addWidget(self.log_text)
        layout.addWidget(log, 1)
        
        return widget
    
    def update_thickness_mode(self):
        """Update thickness input label and range based on selected algorithm"""
        if self.algo_lazy_radio.isChecked():
            # Lazy mode: thickness addition in mm
            self.thickness_label.setText("Thickness (mm):")
            self.thickness_addition.setRange(0.1, 50.0)
            self.thickness_addition.setValue(0.736)
            self.thickness_addition.setDecimals(3)
            self.thickness_addition.setSuffix("")
        else:
            # GP mode: multiplier range
            self.thickness_label.setText("Multiplier:")
            self.thickness_addition.setRange(1.0, 10.0)
            self.thickness_addition.setValue(3.0)
            self.thickness_addition.setDecimals(1)
            # self.thickness_addition.setSuffix("×")
        
    def parse_property_ids(self, input_str: str, bdf) -> Set[int]:
        """
        Parse property ID input string and return set of property IDs.
        
        Supports:
        - 'all': all PCOMP/PCOMPG/PSHELL properties
        - '101,102,103': comma-separated list
        - '101:201': range (inclusive)
        - Mixed: '101,105:110,200'
        
        Args:
            input_str: User input string
            bdf: BDF object to validate against
            
        Returns:
            Set of property IDs
        """
        input_str = input_str.strip().lower()
        
        if input_str == 'all':
            # Get all composite/shell properties
            all_props = set()
            for pid, prop in bdf.properties.items():
                if prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    all_props.add(pid)
            self.log(f"Selected ALL properties: {len(all_props)} found")
            return all_props
        
        # Parse comma-separated values and ranges
        prop_ids = set()
        parts = input_str.split(',')
        
        for part in parts:
            part = part.strip()
            if ':' in part:
                # Range: start:end
                try:
                    start, end = part.split(':')
                    start, end = int(start), int(end)
                    prop_ids.update(range(start, end + 1))
                except ValueError:
                    self.log(f"<span style='color:#ffb74d'>Warning: Invalid range '{part}'</span>")
            else:
                # Single value
                try:
                    prop_ids.add(int(part))
                except ValueError:
                    self.log(f"<span style='color:#ffb74d'>Warning: Invalid ID '{part}'</span>")
        
        # Validate against BDF
        valid_props = set()
        for pid in prop_ids:
            if pid in bdf.properties:
                prop = bdf.properties[pid]
                if prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    valid_props.add(pid)
                else:
                    self.log(f"<span style='color:#ffb74d'>Warning: PID {pid} not composite/shell</span>")
            else:
                self.log(f"<span style='color:#ffb74d'>Warning: PID {pid} not found in BDF</span>")
        
        self.log(f"Selected {len(valid_props)} properties: {sorted(list(valid_props))[:10]}{'...' if len(valid_props) > 10 else ''}")
        return valid_props
        
    
    def log(self, msg):
        self.log_text.append(f"<span style='color:#808080'>{time.strftime('%H:%M:%S')}</span> {msg}")
        QApplication.processEvents()
    
    def my_read_bdf(self, path):
        """Try reading BDF with different parameter combinations"""
        for punch in [False, True]:
            for xref in [False, True]:
                try:
                    return read_bdf(path, xref=xref, punch=punch)
                except:
                    continue
        raise IOError(f"Failed to read BDF: {path}")
    
    def browse_bdf(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select BDF", "", "BDF (*.bdf)")
        if f: self.bdf_path.setText(f)
    
    def browse_op2(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select OP2", "", "OP2 (*.op2)")
        if f: self.op2_path.setText(f)
    
    def browse_excel(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select Excel", "", "Excel (*.xlsx *.xls)")
        if f: self.excel_path.setText(f)
    
    def browse_nastran(self):
        f, _ = QFileDialog.getOpenFileName(self, "Select Nastran", "", "EXE (*.exe)")
        if f: self.nastran_path.setText(f)
        
    
    def start_optimization(self):
        """Main entry point for optimization"""
        # Validate file paths
        for p, n in [(self.bdf_path, "BDF"), (self.op2_path, "OP2"),
                     (self.excel_path, "Excel"), (self.nastran_path, "Nastran")]:
            if not os.path.exists(p.text()):
                QMessageBox.critical(self, "Error", f"{n} not found!")
                return
        
        # Check algorithm selection
        if self.algo_gauss_radio.isChecked() and not SKOPT_AVAILABLE:
            QMessageBox.critical(self, "Error", 
                "Gaussian Process requires scikit-optimize.\nInstall with: pip install scikit-optimize")
            return
        
        # Validate property ID input if manual mode
        if self.prop_manual_radio.isChecked():
            if not self.prop_ids_input.text().strip():
                QMessageBox.critical(self, "Error", "Please enter property IDs!")
                return
        
        self.start_btn.setEnabled(False)
        self.status_label.setText("Running...")
        self.iteration_data = []
        self.node_to_shells_cache = None
        self.target_pcomp_ids = None
        
        # Calculate initial mass
        try:
            bdf = self.my_read_bdf(self.bdf_path.text())
            self.initial_mass, _, _ = mass_properties(bdf)
            self.log(f"<span style='color:#81c784'>Initial mass: {self.initial_mass:.2f} kg</span>")
        except Exception as e:
            self.log(f"<span style='color:#ffb74d'>Warning: Could not calculate mass - {e}</span>")
            self.initial_mass = None
        
        # Run optimization
        try:
            if self.algo_lazy_radio.isChecked():
                ok, msg = self.run_lazy_optimization()
            else:
                ok, msg = self.run_gaussian_optimization()
            
            self.status_label.setText("✓ Done" if ok else "⚠ Stopped")
            self.status_label.setStyleSheet(f"color: {'#81c784' if ok else '#ffb74d'}; font-weight: bold;")
            (QMessageBox.information if ok else QMessageBox.warning)(self, "Result", msg)
        except Exception as e:
            self.status_label.setText("✗ Error")
            self.status_label.setStyleSheet("color: #e57373; font-weight: bold;")
            QMessageBox.critical(self, "Error", str(e))
            self.log(f"<span style='color:#e57373'>ERROR: {e}</span>")
            import traceback
            self.log(f"<span style='color:#e57373'>{traceback.format_exc()}</span>")
        
        self.start_btn.setEnabled(True)
            
        
    def run_lazy_optimization(self):
        """Original iterative thickness addition algorithm"""
        bdf_orig = self.bdf_path.text()
        op2_orig = self.op2_path.text()
        excel = self.excel_path.text()
        nastran = self.nastran_path.text()
        thick_add = self.thickness_addition.value()
        target = self.target_rf.value()
        max_iter = self.max_iterations.value()
        
        work_dir = os.path.dirname(bdf_orig)
        base = os.path.splitext(os.path.basename(bdf_orig))[0]
        
        bdf_work = os.path.join(work_dir, f"{base}_working.bdf")
        op2_work = os.path.join(work_dir, f"{base}_working.op2")
        
        shutil.copy2(bdf_orig, bdf_work)
        if os.path.exists(op2_orig):
            shutil.copy2(op2_orig, op2_work)
        
        # Read Excel ONCE
        self.log("Reading Excel...")
        df_in = pd.read_excel(excel).sort_values('elid').reset_index(drop=True)
        given_list = df_in["elid"].tolist()
        
        # Determine property selection method
        use_neighbor = self.prop_neighbor_radio.isChecked()
        
        if use_neighbor:
            self.log("Property selection: NEIGHBOR APPROACH")
        else:
            self.log("Property selection: MANUAL IDs")
        
        self.log(f"Monitoring {len(df_in)} elements | RF: {target} | +{thick_add}mm")
        self.log("="*60)
        
        iteration = 0
        all_updated = set()
        
        while iteration < max_iter:
            iteration += 1
            self.log(f"\n<span style='color:#4fc3f7;font-weight:bold'>ITERATION {iteration}</span>")
            
            # Read BDF
            bdf = self.my_read_bdf(bdf_work)
            
            # Build connectivity cache (only for neighbor approach)
            if use_neighbor and (self.node_to_shells_cache is None or iteration > 1):
                self.log("Building connectivity cache...")
                self.node_to_shells_cache = self.build_connectivity(bdf)
            
            # Parse manual property IDs if needed (only first iteration)
            if not use_neighbor and iteration == 1:
                self.target_pcomp_ids = self.parse_property_ids(
                    self.prop_ids_input.text(), bdf
                )
                if not self.target_pcomp_ids:
                    return False, "No valid property IDs specified!"
            
            # Read OP2
            try:
                op2 = read_op2(op2_work, build_dataframe=True)
            except:
                op2 = read_op2(op2_orig, build_dataframe=True)
                
            # Calculate RF (with or without neighbor search)
            if use_neighbor:
                df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
            else:
                df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
            
            del op2
            gc.collect()
            
            df_crit = df_res[df_res['RF'] < target]
            n_crit = len(df_crit)
            
            # Mass calculation
            try:
                mass, _, _ = mass_properties(bdf)
            except:
                mass = None
            
            # Update UI
            self.update_progress(iteration, max_iter, n_crit, 
                               df_res['RF'].dropna().tolist(), mass)
            
            # Check convergence
            if n_crit == 0:
                final = os.path.join(work_dir, f"{base}_optimized.bdf")
                shutil.copy2(bdf_work, final)
                res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
                return True, f"✓ Optimization converged!\n\nAll elements meet RF ≥ {target}\n\nResults: {res_file}\nBDF: {final}"
            
            self.log(f"<span style='color:#e57373'>Critical elements: {n_crit}</span>")
            
            # Collect properties to update
            if use_neighbor:
                # Collect from neighbor lists
                pcomp_upd = set()
                for ns in df_crit['neighbors']:
                    if pd.notna(ns) and ns != '[]':
                        try:
                            pcomp_upd.update(ast.literal_eval(ns))
                        except:
                            pass
                
                if not pcomp_upd:
                    return False, "No PCOMP neighbors found for critical elements!"
            else:
                # Use manual property list
                pcomp_upd = self.target_pcomp_ids.copy()
            
            self.log(f"Updating {len(pcomp_upd)} properties")
            
            # Update thicknesses
            upd = self.update_pcomp(bdf, pcomp_upd, thick_add)
            all_updated.update(upd)
            
            # Save iteration files
            iter_dir = os.path.join(work_dir, f"iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            
            iter_bdf = os.path.join(iter_dir, f"{base}_iter{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            
            with pd.ExcelWriter(os.path.join(iter_dir, f"iter{iteration}_results.xlsx")) as w:
                df_res.to_excel(w, 'All', index=False)
                df_crit.to_excel(w, 'Critical', index=False)
            
            shutil.copy2(iter_bdf, bdf_work)
            
            # Run Nastran
            self.log("Running Nastran...")
            if not self.run_nastran(nastran, bdf_work):
                return False, "Nastran analysis failed!"
            
            try:
                src = bdf_work.replace('.bdf', '.op2')
                shutil.copy2(src, op2_work) 
            except:
                pass
            
            """
            # Archive analysis files
            import gc
            for ext in ['.op2', '.f04', '.f06']:
                src = bdf_work.replace('.bdf', ext)
                if os.path.exists(src):
                    dst = os.path.join(iter_dir, os.path.basename(src))
                    
                    max_attempts = 5
                    for attempt in range(max_attempts):
                        try:
                            shutil.copy2(src, dst)  # Just copy, don't move
                            
                            if ext == '.op2':
                                shutil.copy2(src, op2_work)  # Also copy to working
                            
                            self.log(f"<span style='color:#00ff00'>✓ {ext} archived</span>")
                            break
                            
                        except PermissionError:
                            if attempt < max_attempts - 1:
                                time.sleep(1)
                                gc.collect()
                            else:
                                self.log(f"<span style='color:#ffaa00'>⚠ Could not archive {ext}</span>")
            """
        # Max iterations reached
        final = os.path.join(work_dir, f"{base}_optimized_maxiter.bdf")
        shutil.copy2(bdf_work, final)
        res_file = self.save_results(work_dir, base, iteration, df_res, all_updated)
        return False, f"⚠ Max iterations reached\n\nCritical elements: {n_crit}\n\nResults: {res_file}\nBDF: {final}"
    
    def run_gaussian_optimization(self):
        """Gaussian Process optimization using scikit-optimize"""
        bdf_orig = self.bdf_path.text()
        op2_orig = self.op2_path.text()
        excel = self.excel_path.text()
        nastran = self.nastran_path.text()
        target_rf = self.target_rf.value()
        max_iter = self.max_iterations.value()
        
        work_dir = os.path.dirname(bdf_orig)
        base = os.path.splitext(os.path.basename(bdf_orig))[0]
        
        bdf_work = os.path.join(work_dir, f"{base}_working.bdf")
        op2_work = os.path.join(work_dir, f"{base}_working.op2")
        
        # Read Excel
        self.log("Reading Excel...")
        df_in = pd.read_excel(excel).sort_values('elid').reset_index(drop=True)
        given_list = df_in["elid"].tolist()
        
        # Determine property selection
        use_neighbor = self.prop_neighbor_radio.isChecked()
        
        if use_neighbor:
            self.log("Property selection: NEIGHBOR APPROACH")
            # Need to do one RF calculation to find neighbors
            shutil.copy2(bdf_orig, bdf_work)
            shutil.copy2(op2_orig, op2_work)
            
            bdf = self.my_read_bdf(bdf_work)
            self.node_to_shells_cache = self.build_connectivity(bdf)
            op2 = read_op2(op2_work, build_dataframe=True)
            
            # Initialize as empty set BEFORE first calculation
            self.target_pcomp_ids = set()
    
            df_res = self.calc_rf_with_neighbors(bdf, op2, df_in, given_list)
            df_crit = df_res[df_res['RF'] < target_rf]
            
            # Collect all neighbor properties
            pcomp_target = set()
            for ns in df_crit['neighbors']:
                if pd.notna(ns) and ns != '[]':
                    try:
                        pcomp_target.update(ast.literal_eval(ns))
                    except:
                        pass
            
            if not pcomp_target:
                return False, "No PCOMP neighbors found!"
            
            self.target_pcomp_ids = pcomp_target
            
            del op2, bdf
            gc.collect()
    
        else:
            self.log("Property selection: MANUAL IDs")
            bdf = self.my_read_bdf(bdf_orig)
            self.target_pcomp_ids = self.parse_property_ids(
                self.prop_ids_input.text(), bdf
            )
            if not self.target_pcomp_ids:
                return False, "No valid property IDs specified!"
        
        self.log(f"Optimizing {len(self.target_pcomp_ids)} properties")
        self.log(f"Target RF: {target_rf}")
        self.log("="*60)
        
        # Store original thicknesses
        bdf_orig_obj = self.my_read_bdf(bdf_orig)
        original_thicknesses = {}
        for pid in self.target_pcomp_ids:
            prop = bdf_orig_obj.properties[pid]
            if prop.type in ['PCOMP', 'PCOMPG']:
                original_thicknesses[pid] = prop.thicknesses[0]
            elif prop.type == 'PSHELL':
                original_thicknesses[pid] = prop.t
        
        # Define objective function
        iteration_count = [0]
        
        def objective(thickness_multipliers):
            """
            Objective: minimize (critical_count + mass_penalty)
            
            thickness_multipliers: list of multipliers for each target property
            """
            iteration_count[0] += 1
            iteration = iteration_count[0]
            
            self.log(f"\n<span style='color:#4fc3f7;font-weight:bold'>GP ITERATION {iteration}</span>")
            
            # Create modified BDF
            shutil.copy2(bdf_orig, bdf_work)
            bdf = self.my_read_bdf(bdf_work)
            
            # Apply thickness multipliers
            for i, pid in enumerate(sorted(self.target_pcomp_ids)):
                multiplier = thickness_multipliers[i]
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    prop.thicknesses[0] = original_thicknesses[pid] * multiplier
                elif prop.type == 'PSHELL':
                    prop.t = original_thicknesses[pid] * multiplier
            
            # Save modified BDF
            iter_dir = os.path.join(work_dir, f"gp_iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            iter_bdf = os.path.join(iter_dir, f"{base}_gp{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            shutil.copy2(iter_bdf, bdf_work)
            
            # Run Nastran
            self.log("Running Nastran...")
            if not self.run_nastran(nastran, bdf_work):
                self.log("<span style='color:#e57373'>Nastran failed, returning penalty</span>")
                return 1e6  # Large penalty
            
            # Wait a bit for file handles to be released
            time.sleep(0.5)
            
            # Archive OP2
            op2_src = bdf_work.replace('.bdf', '.op2')
            if os.path.exists(op2_src):
                # Try multiple times with delays
                max_attempts = 5
                for attempt in range(max_attempts):
                    try:
                        shutil.copy2(op2_src, op2_work)
                        shutil.copy2(op2_src, os.path.join(iter_dir, os.path.basename(op2_src)))
                        break
                    except PermissionError:
                        if attempt < max_attempts - 1:
                            time.sleep(1)
                            gc.collect()
                        else:
                            self.log("<span style='color:#ffb74d'>Warning: Could not archive OP2</span>")
            
            # Calculate RF
            try:
                op2 = read_op2(op2_work, build_dataframe=True)
                df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
                
                # IMPORTANT: Delete op2 object and force garbage collection
                del op2
                gc.collect()
                
                df_crit = df_res[df_res['RF'] < target_rf]
                n_crit = len(df_crit)
                
                # Calculate mass
                try:
                    mass, _, _ = mass_properties(bdf)
                except:
                    mass = None
                
                # Delete BDF object too
                del bdf
                gc.collect()
                
                # Update UI
                self.update_progress(iteration, max_iter, n_crit,
                                   df_res['RF'].dropna().tolist(), mass)
                
                # Objective: minimize critical count + mass penalty
                mass_penalty = 0
                if mass and self.initial_mass:
                    mass_increase = (mass - self.initial_mass) / self.initial_mass
                    mass_penalty = max(0, mass_increase * 100)  # Penalize mass increase
                
                objective_value = n_crit + mass_penalty
                
                self.log(f"Critical: {n_crit}, Mass penalty: {mass_penalty:.2f}, Objective: {objective_value:.2f}")
                
                # Save results
                with pd.ExcelWriter(os.path.join(iter_dir, f"gp{iteration}_results.xlsx")) as w:
                    df_res.to_excel(w, 'All', index=False)
                    df_crit.to_excel(w, 'Critical', index=False)
                
                return objective_value
                
            except Exception as e:
                self.log(f"<span style='color:#e57373'>Error in evaluation: {e}</span>")
                return 1e6
    
        def objective_(thickness_multipliers):
            """
            Objective: minimize (critical_count + mass_penalty)
            
            thickness_multipliers: list of multipliers for each target property
            """
            iteration_count[0] += 1
            iteration = iteration_count[0]
            
            self.log(f"\n<span style='color:#4fc3f7;font-weight:bold'>GP ITERATION {iteration}</span>")
            
            # Create modified BDF
            shutil.copy2(bdf_orig, bdf_work)
            bdf = self.my_read_bdf(bdf_work)
            
            # Apply thickness multipliers
            for i, pid in enumerate(sorted(self.target_pcomp_ids)):
                multiplier = thickness_multipliers[i]
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    prop.thicknesses[0] = original_thicknesses[pid] * multiplier
                elif prop.type == 'PSHELL':
                    prop.t = original_thicknesses[pid] * multiplier
            
            # Save modified BDF
            iter_dir = os.path.join(work_dir, f"gp_iteration_{iteration}")
            os.makedirs(iter_dir, exist_ok=True)
            iter_bdf = os.path.join(iter_dir, f"{base}_gp{iteration}.bdf")
            bdf.write_bdf(iter_bdf)
            shutil.copy2(iter_bdf, bdf_work)
            
            # Run Nastran
            self.log("Running Nastran...")
            if not self.run_nastran(nastran, bdf_work):
                self.log("<span style='color:#e57373'>Nastran failed, returning penalty</span>")
                return 1e6  # Large penalty
            
            # Archive OP2
            op2_src = bdf_work.replace('.bdf', '.op2')
            if os.path.exists(op2_src):
                shutil.copy2(op2_src, op2_work)
                shutil.move(op2_src, os.path.join(iter_dir, os.path.basename(op2_src)))
            
            # Calculate RF
            try:
                op2 = read_op2(op2_work, build_dataframe=True)
                df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
                
                df_crit = df_res[df_res['RF'] < target_rf]
                n_crit = len(df_crit)
                
                # Calculate mass
                try:
                    mass, _, _ = mass_properties(bdf)
                except:
                    mass = None
                
                # Update UI
                self.update_progress(iteration, max_iter, n_crit,
                                   df_res['RF'].dropna().tolist(), mass)
                
                # Objective: minimize critical count + mass penalty
                mass_penalty = 0
                if mass and self.initial_mass:
                    mass_increase = (mass - self.initial_mass) / self.initial_mass
                    mass_penalty = max(0, mass_increase * 100)  # Penalize mass increase
                
                objective_value = n_crit + mass_penalty
                
                self.log(f"Critical: {n_crit}, Mass penalty: {mass_penalty:.2f}, Objective: {objective_value:.2f}")
                
                # Save results
                with pd.ExcelWriter(os.path.join(iter_dir, f"gp{iteration}_results.xlsx")) as w:
                    df_res.to_excel(w, 'All', index=False)
                    df_crit.to_excel(w, 'Critical', index=False)
                
                return objective_value
                
            except Exception as e:
                self.log(f"<span style='color:#e57373'>Error in evaluation: {e}</span>")
                return 1e6
        
        # Define search space (thickness multipliers)
        # Allow 0.5x to 3.0x of original thickness
        n_props = len(self.target_pcomp_ids)
        max_multi=self.thickness_addition.value()
        space = [Real(1.0, max_multi, name=f'mult_{i}') for i in range(n_props)]
        
        # Initial guess: 1.0x (original thickness)
        x0 = [1.0] * n_props
        
        self.log(f"Starting Gaussian Process optimization...")
        self.log(f"Search space: {n_props} properties, multipliers [1.0, f{max_multi:.1f}]")
        
        # Run optimization
        try:
            result = gp_minimize(
                objective,
                space,
                x0=[x0],
                n_calls=min(max_iter, 30),  # Limit GP iterations
                random_state=42,
                verbose=False
            )
            
            self.log(f"\n<span style='color:#81c784'>GP Optimization complete!</span>")
            self.log(f"Best objective: {result.fun:.2f}")
            self.log(f"Best multipliers: {[f'{x:.3f}' for x in result.x]}")
            
            # Apply best solution
            shutil.copy2(bdf_orig, bdf_work)
            bdf = self.my_read_bdf(bdf_work)
            
            for i, pid in enumerate(sorted(self.target_pcomp_ids)):
                multiplier = result.x[i]
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    new_thick = original_thicknesses[pid] * multiplier
                    prop.thicknesses[0] = new_thick
                    self.log(f"  PID {pid}: {original_thicknesses[pid]:.3f} → {new_thick:.3f} mm (×{multiplier:.3f})")
                elif prop.type == 'PSHELL':
                    new_thick = original_thicknesses[pid] * multiplier
                    prop.t = new_thick
                    self.log(f"  PID {pid}: {original_thicknesses[pid]:.3f} → {new_thick:.3f} mm (×{multiplier:.3f})")
            
            # Save final BDF
            final = os.path.join(work_dir, f"{base}_optimized_gp.bdf")
            bdf.write_bdf(final)
            
            # Final evaluation
            bdf.write_bdf(bdf_work)
            self.run_nastran(nastran, bdf_work)
            
            # Wait for file handles to be released
            time.sleep(1.0)
            gc.collect()

            op2_src = bdf_work.replace('.bdf', '.op2')
            if os.path.exists(op2_src):
                # Retry logic for copying OP2
                max_attempts = 5
                copied = False
                for attempt in range(max_attempts):
                    try:
                        shutil.copy2(op2_src, op2_work)
                        copied = True
                        self.log("<span style='color:#81c784'>✓ OP2 archived</span>")
                        break
                    except PermissionError:
                        if attempt < max_attempts - 1:
                            self.log(f"<span style='color:#ffb74d'>Retrying OP2 copy ({attempt+1}/{max_attempts})...</span>")
                            time.sleep(1)
                            gc.collect()
                        else:
                            self.log("<span style='color:#e57373'>⚠ Could not copy OP2, using source directly</span>")
                
                # If copy failed, use source file directly
                if not copied:
                    op2_work = op2_src
            
            op2 = read_op2(op2_work, build_dataframe=True)
            df_res = self.calc_rf_simple(bdf, op2, df_in, given_list)
            
            # Clean up immediately after use
            del op2
            gc.collect()
            
            res_file = self.save_results(work_dir, base, iteration_count[0], 
                                        df_res, self.target_pcomp_ids)
            
            n_crit_final = len(df_res[df_res['RF'] < target_rf])
            
            if n_crit_final == 0:
                return True, f"✓ GP Optimization converged!\n\nResults: {res_file}\nBDF: {final}"
            else:
                return False, f"⚠ GP completed but {n_crit_final} critical elements remain\n\nResults: {res_file}\nBDF: {final}"
                
        except Exception as e:
            self.log(f"<span style='color:#e57373'>GP optimization error: {e}</span>")
            raise
        
        
    def calc_rf_with_neighbors(self, bdf, op2, df_in, given_list):
        """
        Calculate RF WITH neighbor detection (original algorithm)
        Used when neighbor approach is selected
        """
        # Get forces
        cbar = getattr(op2.op2_results.force, 'cbar_force', None) or op2.cbar_force
        
        # Concat all load cases with proper index reset
        df_f = pd.concat([df.dataframe.reset_index().assign(LoadCase=lc) 
                         for lc, df in cbar.items()], ignore_index=True)
        
        # Filter & envelope
        df_f = df_f[df_f['ElementID'].isin(given_list)]
        df_env = df_f.loc[df_f.groupby('ElementID')['axial'].idxmax(), 
                         ['ElementID', 'axial', 'LoadCase']].reset_index(drop=True)
        
        # Merge
        df_res = df_in.merge(df_env, left_on='elid', right_on='ElementID', how='left')
        df_res.drop(columns=['ElementID'], inplace=True)
        
        # Vectorized calculation with neighbor detection
        dims, neighs, strs, rfs = [], [], [], []
        
        for _, row in df_res.iterrows():
            elem = bdf.elements[row['elid']]
            prop = bdf.properties[elem.pid]
            
            if prop.type == "PBARL":
                w, t = prop.dim[0], prop.dim[1]
                dims.append([w, t])
                
                # Find neighbors
                neighs.append(self.find_neighbors(bdf, row['elid'], 
                                                 self.angle_tolerance))
                
                stress = row['axial'] / (w * t)
                strs.append(stress)
                rfs.append(abs(row['allowable'] / (stress + 1e-6)))
            else:
                dims.append(None)
                neighs.append([])
                strs.append(np.nan)
                rfs.append(np.nan)
        
        thicknesses=[]
        for pid in sorted(list(self.target_pcomp_ids)):
            if bdf.properties[pid].type=="PCOMP":
                thicknesses.append(bdf.properties[pid].thicknesses[0])
            elif bdf.properties[pid].type=="PSHELL":
                thicknesses.append(bdf.properties[pid].t)
                
        df_res['dim'] = [str(d) for d in dims]
        df_res['neighbors'] = [str(n) for n in neighs]
        df_res['neighbors_thicks'] = str(thicknesses)
        df_res['stress'] = strs
        df_res['RF'] = rfs
        
        return df_res
    
    def calc_rf_simple(self, bdf, op2, df_in, given_list):
        """
        Calculate RF WITHOUT neighbor detection (simplified)
        Used when manual property IDs are specified or for GP optimization
        """
        # Get forces
        cbar = getattr(op2.op2_results.force, 'cbar_force', None) or op2.cbar_force
        
        # Concat all load cases
        df_f = pd.concat([df.dataframe.reset_index().assign(LoadCase=lc) 
                         for lc, df in cbar.items()], ignore_index=True)
        
        # Filter & envelope
        df_f = df_f[df_f['ElementID'].isin(given_list)]
        df_env = df_f.loc[df_f.groupby('ElementID')['axial'].idxmax(), 
                         ['ElementID', 'axial', 'LoadCase']].reset_index(drop=True)
        
        # Merge
        df_res = df_in.merge(df_env, left_on='elid', right_on='ElementID', how='left')
        df_res.drop(columns=['ElementID'], inplace=True)
        
        # Calculate stress and RF (no neighbor detection)
        dims, strs, rfs = [], [], []
        
        for _, row in df_res.iterrows():
            elem = bdf.elements[row['elid']]
            prop = bdf.properties[elem.pid]
            
            if prop.type == "PBARL":
                w, t = prop.dim[0], prop.dim[1]
                dims.append([w, t])
                
                stress = row['axial'] / (w * t)
                strs.append(stress)
                rfs.append(abs(row['allowable'] / (stress + 1e-6)))
            else:
                dims.append(None)
                strs.append(np.nan)
                rfs.append(np.nan)
        
        thicknesses=[]
        for pid in sorted(list(self.target_pcomp_ids)):
            if bdf.properties[pid].type=="PCOMP":
                thicknesses.append(bdf.properties[pid].thicknesses[0])
            elif bdf.properties[pid].type=="PSHELL":
                thicknesses.append(bdf.properties[pid].t)
                
        df_res['dim'] = [str(d) for d in dims]
        df_res['chosen_pids'] = str(sorted(list(self.target_pcomp_ids)))
        df_res['chosen_thicks'] = str(thicknesses)
        df_res['stress'] = strs
        df_res['RF'] = rfs
        
        return df_res
    
    
    def find_neighbors(self, bdf, elid: int, tol: float = 30.0) -> List[int]:
        """
        Find neighboring PCOMP/PSHELL properties connected to a CBAR element
        
        Args:
            bdf: BDF object
            elid: Element ID of the CBAR
            tol: Angle tolerance in degrees (default 30°)
            
        Returns:
            List of property IDs
        """
        bar = bdf.elements[elid]
        
        # Get bar element coordinates
        p1 = np.array(bdf.nodes[bar.nodes[0]].get_position())
        p2 = np.array(bdf.nodes[bar.nodes[1]].get_position())
        
        # Bar x-axis (along element)
        bar_x = (p2 - p1)
        bar_x /= np.linalg.norm(bar_x)
        
        # Bar orientation vector
        v = (np.array(bdf.nodes[bar.g0].get_position()) - p1 if bar.g0 
             else np.array(bar.x))
        
        # Check if v is parallel to bar_x
        if np.abs(np.dot(v/np.linalg.norm(v), bar_x)) > 0.99:
            # Choose perpendicular vector
            v = np.array([1,0,0]) if np.abs(bar_x[0]) < 0.9 else np.array([0,1,0])
        
        # Bar y-axis (perpendicular to x in orientation plane)
        v_proj = v - np.dot(v, bar_x) * bar_x
        bar_y = v_proj / np.linalg.norm(v_proj)
        
        # Bar z-axis (normal to cross-section)
        bar_z = np.cross(bar_x, bar_y)
        
        # Fast lookup using connectivity cache
        cands = set()
        for nid in bar.nodes:
            cands.update(self.node_to_shells_cache.get(nid, []))
        
        neighs = []
        bar_set = set(bar.nodes)
        
        # Check each candidate shell element
        for eid in cands:
            elem = bdf.elements[eid]
            
            # Must share at least 2 nodes with bar
            if len(set(elem.nodes) & bar_set) >= 2:
                prop = bdf.properties.get(elem.pid)
                
                if prop and prop.type in ['PCOMP', 'PCOMPG', 'PSHELL']:
                    # Get shell nodes (first 3-4 for normal calculation)
                    nodes = (elem.nodes[:4] if elem.type in ['CQUAD4','CQUAD8'] 
                            else elem.nodes[:3])
                    
                    p0 = np.array(bdf.nodes[nodes[0]].get_position())
                    p1 = np.array(bdf.nodes[nodes[1]].get_position())
                    p2 = np.array(bdf.nodes[nodes[2]].get_position())
                    
                    # Shell normal
                    norm = np.cross(p1-p0, p2-p0)
                    norm /= np.linalg.norm(norm)
                    
                    # Angle between shell normal and bar z-axis
                    ang = np.arccos(np.clip(np.abs(np.dot(bar_z, norm)), 0, 1)) * 180/np.pi
                    
                    # If within tolerance, add property ID
                    if ang <= tol and elem.pid not in neighs:
                        neighs.append(elem.pid)
        
        return neighs
    
    def build_connectivity(self, bdf) -> Dict[int, List[int]]:
        """
        Build node-to-shell-element connectivity map
        
        Args:
            bdf: BDF object
            
        Returns:
            Dictionary mapping node IDs to list of shell element IDs
        """
        node_to_elems = {}
        
        for eid, elem in bdf.elements.items():
            if elem.type in ['CQUAD4', 'CTRIA3', 'CQUAD8', 'CTRIA6']:
                for nid in elem.nodes:
                    node_to_elems.setdefault(nid, []).append(eid)
        
        self.log(f"Built connectivity: {len(node_to_elems)} nodes")
        return node_to_elems
    
    def update_pcomp(self, bdf, pids: Set[int], add_mm: float) -> List[int]:
        """
        Update PCOMP/PSHELL thicknesses by adding specified amount
        
        Args:
            bdf: BDF object
            pids: Set of property IDs to update
            add_mm: Thickness to add in mm
            
        Returns:
            List of successfully updated property IDs
        """
        upd = []
        
        for pid in sorted(pids):
            if pid in bdf.properties:
                prop = bdf.properties[pid]
                
                if prop.type in ['PCOMP', 'PCOMPG']:
                    old_thick = prop.thicknesses[0]
                    prop.thicknesses[0] += add_mm
                    new_thick = prop.thicknesses[0]
                    total = sum(prop.thicknesses)
                    
                    upd.append(pid)
                    self.log(f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm (total: {total:.3f} mm)")
                    
                elif prop.type == 'PSHELL':
                    old_thick = prop.t
                    prop.t += add_mm
                    new_thick = prop.t
                    
                    upd.append(pid)
                    self.log(f"  PID {pid}: {old_thick:.3f} → {new_thick:.3f} mm")
        
        return upd
    
    def run_nastran(self, exe: str, bdf: str) -> bool:
        """
        Run Nastran analysis
        
        Args:
            exe: Path to Nastran executable
            bdf: Path to BDF file
            
        Returns:
            True if successful, False otherwise
        """
        
        def wait_for_nastran():
            while True:
                running = [p for p in psutil.process_iter(["name"]) if p.info["name"] == "nastran.exe"]
                if not running:
                    break
                time.sleep(0.5)

        try:
            # result = subprocess.run(
            #     [exe, os.path.basename(bdf)],
            #     cwd=os.path.dirname(bdf),
            #     capture_output=True,
            #     text=True,
            #     timeout=3600  # 1 hour timeout
            # )
            
            result = subprocess.call(
                [exe, os.path.basename(bdf), "scr=yes", "old=no"],
                cwd=os.path.dirname(bdf),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            wait_for_nastran()  # Use thread's own method
            
            if result != 0:
                self.log(f"<span style='color:#e57373'>Nastran failed: {result.stderr[:200]}</span>")
                return False
            
            self.log("<span style='color:#81c784'>Nastran completed successfully</span>")
            return True
            
        except subprocess.TimeoutExpired:
            self.log("<span style='color:#e57373'>Nastran timeout (>1 hour)!</span>")
            return False
        except Exception as e:
            self.log(f"<span style='color:#e57373'>Nastran error: {e}</span>")
            return False
        
    def update_progress(self, iteration: int, max_iter: int, 
                       n_crit: int, rf_values: List[float], mass: Optional[float]):
        """
        Update progress bar, labels, and store iteration data
        
        Args:
            iteration: Current iteration number
            max_iter: Maximum iterations
            n_crit: Number of critical elements
            rf_values: List of RF values
            mass: Current mass in kg (or None)
        """
        # Update progress bar
        self.progress.setValue(int(iteration / max_iter * 100))
        
        # Update labels
        self.iteration_label.setText(f"{iteration}/{max_iter}")
        self.critical_label.setText(str(n_crit))
        
        # Store iteration data
        self.iteration_data.append({
            'iteration': iteration,
            'critical_count': n_crit,
            'rf_values': rf_values,
            'mass': mass
        })
        
        # Update plots
        self.update_plots()
    
    def update_plots(self):
        if not self.iteration_data:
            return
        
        iters = [d['iteration'] for d in self.iteration_data]
        crits = [d['critical_count'] for d in self.iteration_data]
        
        # Plot 1 - Half-Life orange/red
        self.ax1.clear()
        self.ax1.plot(iters, crits, 'o-', color='#ff4400', lw=1.5, ms=4, label='Critical')
        self.ax1.axhline(0, color='#00ff00', ls='--', lw=1, label='Target', alpha=0.7)
        self.ax1.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
        self.ax1.set_ylabel('Critical Elements', color='#888888', fontsize=9, family='monospace')
        self.ax1.set_title('CONVERGENCE', color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
        self.ax1.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
        self.ax1.tick_params(colors='#666666', labelsize=8)
        self.ax1.legend(facecolor='#1a1a1a', edgecolor='#ff6600', loc='best', framealpha=0.9, fontsize=8)
        self.ax1.set_facecolor('#0f0f0f')
        for spine in ['bottom', 'left']:
            self.ax1.spines[spine].set_color('#ff6600')
        for spine in ['top', 'right']:
            self.ax1.spines[spine].set_color('#444444')
        self.ax1.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
        
        # Plot 2
        self.ax2.clear()
        mass_iters = [d['iteration'] for d in self.iteration_data if d.get('mass') is not None]
        mass_vals = [d['mass'] for d in self.iteration_data if d.get('mass') is not None]
        
        if mass_vals:
            self.ax2.plot(mass_iters, mass_vals, 'o-', color='#ff6600', lw=1.5, ms=4, label='Mass')
            if self.initial_mass:
                self.ax2.axhline(self.initial_mass, color='#ffaa00', ls='--', lw=1, 
                               label=f'Initial', alpha=0.7)
            
            self.ax2.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
            self.ax2.set_ylabel('Mass (kg)', color='#888888', fontsize=9, family='monospace')
            self.ax2.set_title('MASS', color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
            self.ax2.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
            self.ax2.tick_params(colors='#666666', labelsize=8)
            self.ax2.legend(facecolor='#1a1a1a', edgecolor='#ff6600', loc='best', framealpha=0.9, fontsize=8)
            self.ax2.set_facecolor('#0f0f0f')
            for spine in ['bottom', 'left']:
                self.ax2.spines[spine].set_color('#ff6600')
            for spine in ['top', 'right']:
                self.ax2.spines[spine].set_color('#444444')
            self.ax2.xaxis.set_major_locator(plt.MaxNLocator(integer=True))
            
            if self.initial_mass and len(mass_vals) > 0:
                final_mass = mass_vals[-1]
                pct_change = ((final_mass - self.initial_mass) / self.initial_mass) * 100
                color = '#ff4400' if pct_change > 0 else '#00ff00'
                self.ax2.text(0.02, 0.98, f'Δ {pct_change:+.1f}%', 
                            transform=self.ax2.transAxes, verticalalignment='top',
                            color=color, fontweight='bold', fontsize=9, family='monospace',
                            bbox=dict(boxstyle='round,pad=0.3', facecolor='#1a1a1a', 
                                    edgecolor=color, linewidth=1))
        
        self.fig.tight_layout(pad=2.0)
        self.canvas.draw()
        QApplication.processEvents()
    
    def create_right_panel(self):
        """Create right panel with Half-Life style plots"""
        widget = QWidget()
        
        # Half-Life style plot settings
        plt.style.use('dark_background')
        
        self.fig = Figure(figsize=(10, 8), facecolor='#0a0a0a')
        self.ax1 = self.fig.add_subplot(211, facecolor='#0f0f0f')
        self.ax2 = self.fig.add_subplot(212, facecolor='#0f0f0f')
        
        for ax, ylabel, title in [
            (self.ax1, 'Critical Elements', 'CONVERGENCE'),
            (self.ax2, 'Mass (kg)', 'MASS')
        ]:
            ax.set_xlabel('Iteration', color='#888888', fontsize=9, family='monospace')
            ax.set_ylabel(ylabel, color='#888888', fontsize=9, family='monospace')
            ax.set_title(title, color='#ff8800', fontweight='bold', fontsize=10, family='monospace')
            ax.grid(True, alpha=0.15, color='#444444', linestyle='-', linewidth=0.5)
            ax.tick_params(colors='#666666', labelsize=8)
            ax.spines['bottom'].set_color('#ff6600')
            ax.spines['top'].set_color('#444444')
            ax.spines['left'].set_color('#ff6600')
            ax.spines['right'].set_color('#444444')
            ax.set_facecolor('#0f0f0f')
        
        self.fig.tight_layout(pad=2.0)
        self.canvas = FigureCanvasQTAgg(self.fig)
        QVBoxLayout(widget).addWidget(self.canvas)
        
        return widget
    
    def save_results(self, work_dir: str, base: str, iteration: int,
                    df_res: pd.DataFrame, updated_pids: Set[int]) -> str:
        """
        Save optimization results to Excel file
        
        Args:
            work_dir: Working directory
            base: Base filename
            iteration: Final iteration number
            df_res: Results DataFrame
            updated_pids: Set of updated property IDs
            
        Returns:
            Path to results file
        """
        res_file = os.path.join(work_dir, f"{base}_RESULTS.xlsx")
        
        # Get algorithm name
        algo_name = "Lazy (Iterative)" if self.algo_lazy_radio.isChecked() else "Gaussian Process"
        prop_method = "Neighbor Approach" if self.prop_neighbor_radio.isChecked() else "Manual IDs"
        
        # Check convergence
        target_rf = self.target_rf.value()
        n_crit_final = len(df_res[df_res['RF'] < target_rf])
        converged = (n_crit_final == 0)
        
        # Calculate final mass
        final_mass = None
        if self.iteration_data and self.iteration_data[-1].get('mass'):
            final_mass = self.iteration_data[-1]['mass']
        
        # Mass change
        mass_change_str = "N/A"
        if self.initial_mass and final_mass:
            mass_change_pct = ((final_mass - self.initial_mass) / self.initial_mass) * 100
            mass_change_str = f"{mass_change_pct:+.2f}%"
        
        # Summary sheet
        df_sum = pd.DataFrame({
            'Parameter': [
                'Algorithm',
                'Property Selection',
                'Status',
                'Converged',
                'Total Iterations',
                'Critical Elements (Final)',
                'Target RF',
                'Initial Mass',
                'Final Mass',
                'Mass Change',
                'Thickness Addition (Lazy)',
                'Angle Tolerance',
                'Properties Modified',
                'Modified Property IDs'
            ],
            'Value': [
                algo_name,
                prop_method,
                'Complete' if converged else 'Max Iterations Reached',
                'Yes' if converged else 'No',
                iteration,
                n_crit_final,
                f"{target_rf:.2f}",
                f"{self.initial_mass:.2f} kg" if self.initial_mass else "N/A",
                f"{final_mass:.2f} kg" if final_mass else "N/A",
                mass_change_str,
                f"{self.thickness_addition.value():.3f} mm" if self.algo_lazy_radio.isChecked() else "N/A",
                f"{self.angle_tolerance:.1f}°",
                len(updated_pids),
                ', '.join(map(str, sorted(list(updated_pids))[:20])) + 
                    ('...' if len(updated_pids) > 20 else '')
            ]
        })
        
        # Iteration history
        df_hist = pd.DataFrame([{
            'Iteration': d['iteration'],
            'Critical_Elements': d['critical_count'],
            'Min_RF': min(d['rf_values']) if d['rf_values'] else None,
            'Max_RF': max(d['rf_values']) if d['rf_values'] else None,
            'Avg_RF': np.mean(d['rf_values']) if d['rf_values'] else None,
            'Std_RF': np.std(d['rf_values']) if d['rf_values'] else None,
            'Mass_kg': d.get('mass')
        } for d in self.iteration_data])
        
        # Critical elements (final)
        df_crit_final = df_res[df_res['RF'] < target_rf].copy()
        
        # Write to Excel with multiple sheets
        with pd.ExcelWriter(res_file, engine='openpyxl') as writer:
            df_sum.to_excel(writer, sheet_name='Summary', index=False)
            df_hist.to_excel(writer, sheet_name='History', index=False)
            df_res.to_excel(writer, sheet_name='All_Elements', index=False)
            df_crit_final.to_excel(writer, sheet_name='Critical_Elements', index=False)
            
            # Auto-adjust column widths
            for sheet_name in writer.sheets:
                worksheet = writer.sheets[sheet_name]
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    adjusted_width = min(max_length + 2, 50)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
        
        self.log(f"<span style='color:#81c784'>Results saved: {res_file}</span>")
        return res_file
    
if __name__ == "__main__":
    app = QApplication(sys.argv)
    
    # Set application metadata
    app.setApplicationName("PCOMP Thickness Optimizer")
    app.setOrganizationName("FEA Tools")
    
    # Create and show GUI
    gui = PCOMPOptimizerGUI()
    gui.showMaximized()
    gui.show()
    
    sys.exit(app.exec_())